\section{Background}
\label{sec:background}
In this section, we briefly overview the background of pub/sub systems and WSN middleware.

\subsection{Publish / Subscribe Systems}
The publish/subscribe (pub/sub) communication paradigm has received an increasing attention because of its loosely coupled nature. Conceptually, a distributed pub/sub system model can be illustrated in Figure \ref{fig:pubsub}.

\begin{figure}
\centering
\figurecurrentwidth{pubsub}
\caption{A conceptual model for distributed pub/sub systems}
\label{fig:pubsub}
\end{figure}

An essential part of a pub/sub system is the event service which is responsible for managing subscriptions and detecting the events based on the subscriptions. Once an event is detected, the corresponding subscribers interested in that event will be notified. The tasks required by the event service are usually done by brokers. In a distributed pub/sub system, there can be many brokers in the network and they usually cooperate with each other in order to provide the event service. Apart from the brokers, a pub/sub system usually include other entities such as subscribers and publishers. Subscribers register their interest in events by calling a subscribe() operation to the event service. To fire an event, a publisher typically calls a publish() operation. The event service notifies the subscribers by calling notify() to all relevant subscribers.

Compared with Traditional interaction paradigms such as message passing, RPC \cite{rpc}, notification \cite{designpattern}, shared spaces \cite{linda} and message queuing \cite{mom}, pub/sub paradigm allows decoupling between publishers and subscribers in three dimensions \cite{facespubsub}.

\begin{itemize}
\item \emph{Space decoupling}: the interacting parties do not need to know each other. The publishers publish events through an event service and the subscribers get these events indirectly from the event service. The publishers do not usually have any reference to these subscribers; neither do they know how many of these subscribers are participating in the interaction. Similarly, subscribers do usually not have any reference to the publishers; neither do they know how many of these publishers are participating in the interaction.
\item \emph{Time decoupling}: the interacting parties do not need to be actively participating in the interaction at the same time. In particular, the publisher might publish some events while the subscriber is disconnected, and conversely, the subscriber might get notified about the occurrence of some event while the original publisher of the event is disconnected.
\item \emph{Flow decoupling}: publishers are not blocked while producing events and subscribers can get notified about the occurrence of some event while performing some concurrent activity (through a callback), i.e., subscribers do not need to pull for events in a synchronous manner. In short, message production and consumption do not happen in the main flow of control of the publisher or subscriber.
\end{itemize}

Because of the decoupling features of pub/sub paradigm, developing applications based on pub/sub paradigm will become easier easy. A few pub/sub systems such as Siena \cite{siena}, Elvin \cite{elvin}, Gryphon \cite{gryphon} and Jedi \cite{jedi} have already been implemented in distributed networks.

\subsection{WSN Middleware}
WSN offers an opportunity for a wide range of applications. The sensor nodes are low cost, low power and easily deployable. When combined, they offer numerous advantages over traditional networks, such as a large-scale flexible architecture, high-resolution sensed data and application adaptive mechanisms. However, due to their tight integration to the physical world, sensor networks pose considerable impediments and make application development nontrivial. Using middleware to bridge the gap between applications and low-level constructs is an attractive approach to resolving many WSN issues and easing the application development. Consequently, a lot of WSN middlewares have been proposed and they provide different kinds of programming abstraction.

Conventionally, middleware is a software layer between operating system and applications. It abstracts the underlying details provided by OS and provides a high level API for applications. The purpose of middleware is usually for easier application development because the application developers can make use of the easier and higher level API instead of the ones provided by OS. WSN middleware is similar in the sense the middleware also sits between the operating system and the application. Moreover, WSN middleware allows the application to view the network as a whole and therefore, program it without being aware of where the data is stored and transmitted. A conceptual model for a WSN middleware is illustrated in Figure \ref{fig:middleware}.

\begin{figure}
\centering
\figurecurrentwidth {middleware}
\caption{WSN middleware}
\label{fig:middleware}
\end{figure}

\subsection{Events and Subscriptions}
In our pub/sub model, each event is a list of attributes which are the actual data obtained from the sensor network \cite{lowlevelnaming}. Applications can subscribe events with subscriptions which contain event types \cite{facespubsub} and event filters \cite{siena}. Events can have relations among each other. The relations are expressed as event operators.

Events together with their relations can be represented as a directed acyclic graph where each node represents an event and the each edge represents a relation. If the relations are all binary relations, each node in the graph can have an indegree of either 0 or 2. Figure \ref{fig:eventhierarchy} shows an example of such a graph. The nodes with 0 indegree represent primitive events. The rest of the nodes represent composite events. The event which has 0 outdegree is the subscribed event.

\begin{figure}
\centering
\subfloat[Event hierarchy]{\label{fig:eventhierarchy}\figurehalfwidth{eventhierarchy}}
\subfloat[Event detection through aggrgation]{\label{fig:event-detection1}\figurehalfwidth{event-detection1}}
\caption{Event definition and detection}
\label{fig:defndetection}
\end{figure}

Once the subscriptions are defined, it will be disseminated into the network so that sensor nodes can start to collect data and detect events. The sensor nodes collect data in rounds. In each round, the collected data will be matched against the subscription. If an event is found to match the subscribed event type, it will be delivered to the sink to notify the subscriber.

\subsection{Event Detection and Detection Cost}
Events can be detected with different strategies based on their types and relations. In this work, we consider the detection cost as message cost. The simplest type of event is the primitive event. Existing work may not have a clear definition on primitive events in the sense that such event may be detected by a single node or by multiple nodes. In the case of multiple nodes, the events are usually detected in the form of data aggregation with aggregates such as average, max or sum. For the sake of discussion, in this work, we consider primitive events as only those that can be detected by single sensor node. For events which involve data aggregation, we consider them as composite events as discussed shortly. Since such detection does not involve collaboration among nodes, the communication cost for detecting primitive events is always zero. 

The second type of event is composite event. Composite events are detected based on a number of sub-events. These sub-events may be primitive or composite events. Apparently, nodes must collaborate in order to detect composite events. Therefore, the communication cost for detecting a composite event comprise of the communication cost for each sub-event and the additional cost for forwarding these sub-events to a node for detection. Figure \ref{fig:event-detection1} shows an example of a composite event that merely aggregates the primitive events. Since four primitive events are used, the communication cost for detecting the event is 4. 

Apart from data aggregation such as sum, max or average, a composite event may require more complicated spatial or temporal relations among its sub-events. A sensor node then needs to be selected to first save the detected sub-events. As shown in Figure \ref{fig:event-detection2} if a composite event is detected based on two or more sub-events \(e_1\) and \(e_2\), then the detected \(e_1\) and \(e_2\) will first be forwarded to a node in their topological center. In this paper, we refer to such node as event fusion point. The communication cost for detecting the composite event will be the cost for detecting each individual sub-events together with the cost for delivering the event detection results to the event fusion point.

\begin{figure}
\centering
\figurecurrentwidth{event-detection2}
\caption{Composite event detection through event fusion point}
\label{fig:event-detection2}
\end{figure}

Sometimes the sub-events may not always happen. In this case, we don't need to always send the results to the event fusion point. Instead, we can forward only the detected events in order to further save the energy. For example, as shown in Figure \ref{fig:event-detection3}, if we have two events \(e_1\) and \(e_2\) which have a relation such that the composite event happens only when both events have been successfully detected. If \(e_2\) needs to be monitored at a higher rate than \(e_1\) and the probability that \(e_2\) will really occur is also higher than that of \(e_1\). Then we can further move the fusion point closer to \(e_2\) so that the nodes do not need to start detecting less frequent \(e_2\) if \(e_1\) has not been detected. In this way, we can further reduce the communication cost because the nodes do not need to spend energy continuously trying to detect \(e_2\).

\begin{figure}
\centering
\figurecurrentwidth{event-detection3}
\caption{Composite event detection using event probability}
\label{fig:event-detection3}
\end{figure}

\subsection{Composite Event-based Applications}
We consider several applications that motivated the development of PSWare. The first one is indoor monitoring for fire detection. When a fire occurs, usually more than one sensor node can detect changes in sensory data such as temperature and light. In addition, when the rescue team comes, they not only need to know the location of the fire but also its spreading speed and direction. This requires detecting changing patterns of the events. In such applications, events will be defined as location of the sensors along with the changes of temperature and light over the time.

The second application is WSN-based structural health monitoring (SHM). The objective of such system is to detect damages on structures such as buildings and bridges if they occur. Event detection is important in these applications because the SHM sensors will introduce high energy consumption during damage detection. It is therefore more desirable to wake them up only upon the occurrence of certain events \cite{jangshm}. One of such example is to start the sensors when certain vibration pattern has been detected on the building to be monitored. In such applications, events may be defined as vibration patterns over the structure.

Our last application is intelligent transportation systems (ITS). ITS may include a wide array of applications such as traffic light control, road enforcement and congestion information. Many of such applications need the vehicle information. In these applications, we may define vehicle related events as primitive events. Then based on those events, different applications may define different composite events which are important to the services being provided.

From these applications, we can see event detection is an essential part. Moreover, for each application domain, it usually have some basic events such as car events for ITS and temperature event for fire monitoring. Then based on these basic events, different composite events may be defined to further meet the requirements of these applications.
