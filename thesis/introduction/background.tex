\section{Background}
\label{sec:background}
In this section, we briefly overview the background of pub/sub systems and WSN middleware.

\subsection{Publish / Subscribe Systems}
The publish/subscribe (pub/sub) communication paradigm has received an increasing attention because of its loosely coupled nature. Conceptually, a distributed pub/sub system model can be illustrated in Figure \ref{fig:pubsub}.

\begin{figure}
\centering
\figurecurrentwidth{pubsub}
\caption{A conceptual model for distributed pub/sub systems}
\label{fig:pubsub}
\end{figure}

An essential part of a pub/sub system is the event service which is responsible for managing subscriptions and detecting the events based on the subscriptions. Once an event is detected, the corresponding subscribers interested in that event will be notified. The tasks required by the event service are usually done by brokers. In a distributed pub/sub system, there can be many brokers in the network and they usually cooperate with each other in order to provide the event service. Apart from the brokers, a pub/sub system usually include other entities such as subscribers and publishers. Subscribers register their interest in events by calling a subscribe() operation to the event service. To fire an event, a publisher typically calls a publish() operation. The event service notifies the subscribers by calling notify() to all relevant subscribers.

Compared with Traditional interaction paradigms such as message passing, RPC \cite{rpc}, notification \cite{designpattern}, shared spaces \cite{linda} and message queuing \cite{mom}, pub/sub paradigm allows decoupling between publishers and subscribers in three dimensions \cite{facespubsub}.

\begin{itemize}
\item \emph{Space decoupling}: the interacting parties do not need to know each other. The publishers publish events through an event service and the subscribers get these events indirectly from the event service. The publishers do not usually have any reference to these subscribers; neither do they know how many of these subscribers are participating in the interaction. Similarly, subscribers do usually not have any reference to the publishers; neither do they know how many of these publishers are participating in the interaction.
\item \emph{Time decoupling}: the interacting parties do not need to be actively participating in the interaction at the same time. In particular, the publisher might publish some events while the subscriber is disconnected, and conversely, the subscriber might get notified about the occurrence of some event while the original publisher of the event is disconnected.
\item \emph{Flow decoupling}: publishers are not blocked while producing events and subscribers can get notified about the occurrence of some event while performing some concurrent activity (through a callback), i.e., subscribers do not need to pull for events in a synchronous manner. In short, message production and consumption do not happen in the main flow of control of the publisher or subscriber.
\end{itemize}

Because of the decoupling features of pub/sub paradigm, developing applications based on pub/sub paradigm will become easier easy. A few pub/sub systems such as Siena \cite{siena}, Elvin \cite{elvin}, Gryphon \cite{gryphon} and Jedi \cite{jedi} have already been implemented in distributed networks.

\subsection{WSN Middleware}
WSN offers an opportunity for a wide range of applications. The sensor nodes are low cost, low power and easily deployable. When combined, they offer numerous advantages over traditional networks, such as a large-scale flexible architecture, high-resolution sensed data and application adaptive mechanisms. However, due to their tight integration to the physical world, sensor networks pose considerable impediments and make application development nontrivial. Using middleware to bridge the gap between applications and low-level constructs is an attractive approach to resolving many WSN issues and easing the application development. Consequently, a lot of WSN middlewares have been proposed and they provide different kinds of programming abstraction.

Conventionally, middleware is a software layer between operating system and applications. It abstract the underlying details provided by OS and provide a high level API for applications. The purpose of middleware is usually for easier application development because the application developers can make use of the easier and higher level API instead of the ones provided by OS. WSN middleware is similar in the sense the middleware also sits between the operating system and the application. Moreover, WSN middleware allows the application to view the network as a whole and therefore, program it without aware where the data is stored and transmitted. A conceptual model for a WSN middleware is illustrated in Figure \ref{fig:middleware}.

\begin{figure}
\centering
\figurecurrentwidth {middleware}
\caption{WSN middleware}
\label{fig:middleware}
\end{figure}

\subsection{Events and Subscriptions}
In our pub/sub model, each event is a list of attributes which are the actual data obtained from the sensor networks \cite{lowlevelnaming}. Applications can subscribe events with subscriptions which contain event types \cite{facespubsub} and event filters \cite{siena}. Events can have relations among each other. The relations are expressed as event operators.

Events together with their relations can be represented as a directed acyclic graph where each node represents an event and the each edge represents a relation. If the relations are all binary relations, each node in the graph can have an indegree of either 0 or 2. Figure \ref{fig:eventhierarchy} shows an example of such a graph. The nodes with 0 indegree represent primitive events. The rest of the nodes represent composite events. The event which has 0 outdegree is the subscribed event.

\begin{figure}
\centering
\subfloat[Event hierarchy]{\label{fig:eventhierarchy}\figurehalfwidth{eventhierarchy}}
\subfloat[Primitive event detection]{\label{fig:event-detection1}\figurehalfwidth{event-detection1}}
\caption{Event definition and detection}
\label{fig:defndetection}
\end{figure}

Once the subscriptions are defined, it will be disseminated into the network so that sensor nodes can start to collect data and detect events. The sensor nodes collect data in rounds. In each round, the collected data will be matched against the subscription. If an event is found to match the subscribed event type, it will be delivered to the sink to notify the subscriber.

\subsection{Event Detection and Detection Cost}
Events can be detected with different strategies based their types and relations. In this work, we consider the detection cost as message cost. The simplest type of event is the primitive events. The cost for detecting this type of event is simply the message cost for one sensor node to reach every other sensor node for this event. As shown in Figure \ref{fig:event-detection1} as an example, if the four nodes are used for detecting event type \(e_1\), the cost will be 4.

The second type of event is composite event. In general, if a composite event is detected based on two sub-events \(e_1\) and \(e_2\) as shown in Figure \ref{fig:event-detection2} then the cost for detecting the composite event will be the cost for detecting each individual events together with the cost for delivering the event detection results to the event fusion point. Here fusion point is simply a sensor node which is responsible for detecting composite event

\begin{figure}
\centering
\figurecurrentwidth{event-detection2}
\caption{Basic composite event detection}
\label{fig:event-detection2}
\end{figure}

Sometimes the events may not always happen. In this case, we don't need to always send the event results to the fusion points. Instead, we can forward only the detected events in order to further save the energy. For example, as shown in Figure \ref{fig:event-detection3}, if we have two events \(e_1\) and \(e_2\) which have a relation such that the composite event happens only when both events have been successfully detected. If \(e_2\) needs to be monitored at a higher rate than \(e_1\) and the probability that \(e_2\) will really occur is also higher than that of \(e_1\). Then we can further move the fusion point closer to \(e_2\). In this way, we can further reduce the energy cost because \(e_2\) doesn't have to be forwarded to the fusion point if \(e_1\) doesn't occur.

\begin{figure}
\centering
\figurecurrentwidth{event-detection3}
\caption{Composite event detection using event probability}
\label{fig:event-detection3}
\end{figure}

\subsection{Composite Event-based Applications}
We consider several applications that motivates the development of PSWare. The first one is about indoor monitoring for fire detection. When a fire occurs, usually more than one sensor nodes can detect changes in sensory data such as temperature and light. In addition, when the rescue team comes, they not only need to know the location of the fire but also its spreading speed and direction. This requires detecting changing patterns of the events. In such applications, events will be defined as location of the sensors along with the changes of temperature and light over the time.

The second application is about WSN-based structural health monitoring (SHM). The objective of such system is to detect damages on structures such as buildings and bridges if they occur. Event detection is important in these applications because the SHM sensors will introduce high energy consumption during damage detection. It is therefore more desirable to wake them up only upon the occurrence of certain events \cite{jangshm}. One of such example is to start the sensors when certain vibration pattern has been detected on the building to be monitored. In such applications, events may be defined as vibration patterns over the structure.

Our last application is an intelligent transportation system (ITS). In addition to the traffic jam example briefly mentioned in Section \ref{sec:introduction}, ITS also provides other services such as traffic light control, road enforcement and congestion information. Many of such services need the vehicle information. In these applications, we may define vehicle related events as primitive events. Then based on those events, different applications may define different composite events which are important to the services being provided.

From these applications, we can see event detection is an essential part. Moreover, for each application domain, it usually have some basic events such as car events for ITS and temperature event for fire monitoring. Then based on these basic events, different composite events may be defined to further meet the requirements of these applications.
