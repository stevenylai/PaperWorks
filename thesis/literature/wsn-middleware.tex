\section{WSN Middleware}
\label{subsec:wsn-middleware}
A lot of works on middleware for WSN have been proposed. Different works provide different features to the upper application layer. In this section, we first describe the issues and challenges in designing middleware for WSN. Then, we survey some of the most important works in the area of middleware for WSN. Finally, we summarize the exiting works and analyze some remaining yet unsolved issues.

\subsection{Issues in Designing WSN Middleware}
\label{sec:middleware-issues}
\begin{figure}
\centering
\figurecurrentwidth{wsn-middleware-issues}
\caption{Issues in designing WSN middleware}
\label{fig:wsn-middleware-issues}
\end{figure}

WSN brings a lot of benefit as well as some challenges. To design and implement an effective and efficient middleware for WSN, theses issues need to be addressed. A few surveys \cite{programmingparadigms, middlewaresurvey1, middlewaresurvey2, middlewarechallenge} have been done to summarize the existing works. In this section, we will select some key issues regarding to the challenges for designing WSN middleware. The overview of the issues is illustrated in Figure \ref{fig:wsn-middleware-issues}. On the left-hand side, abstraction support, data processing and networking may be handled at different software layers. On the right-hand side, QoS and security are usually handled across different software layers.

\emph{Abstraction Support}: WSN usually consists of large number of heterogeneous sensors. These sensors may be developed by different vendors and may have different capability, precision and platform. Therefore, the middleware should hide the underlying platform details and provide a high level programming paradigm for the application programmers. Ideally, a good programming paradigm allows programming the sensor network as a single 'virtual' entity, rather than individual nodes \cite{programmingparadigms}.

\emph{Resource Constraints}: usually each sensor node in the network has limited resources like energy, computing power, memory and communication bandwidth. Hence, middleware components have to be lightweight to fit these constraints. Middleware should also provide support to dynamically adapt performance and resource consumption to the varying needs of the application, for example, by enabling dynamic tradeoffs between output quality and resource consumption. In addition, multiple applications may run on the same network so the middleware needs to fairly allocate resources between different applications.

\emph{Scalability}: scalability is defined as follows. If an application grows, the network should be flexible enough to allow this growth anywhere and anytime without affecting network performance \cite{middlewarechallenge}. As sensor nodes are small and cheaper, sensor networks are usually deployed in very large scales. As a result, middleware should support mechanisms for self-configuration and self-maintenance of collections of sensor nodes. 

\emph{Network Dynamics}: ad hoc networks of sensor nodes may exhibit a highly dynamic network topology because of node mobility, environmental obstructions or hardware failures. Middleware should support the robust operation of sensor networks by coping with the changing network environment. 

\emph{Data Fusion}: most sensor network applications involve nodes that contain redundant data and are located in a specific local region. This property makes it possible for in-network data fusion of data from different sources. Data aggregation saves energy by reducing the total amount of data needs to be transferred.

\emph{Cross-layer Design}: different from traditional middleware which can support a wide variety of applications, WSN middleware cannot be generalized in this way due to limited resource availability. Therefore, most works on WSN middleware include mechanisms for including the application knowledge in the middleware. This lets developers may application requirements to network parameters, which enable them to fine-tune network monitoring. Much existing middleware is coupled to a specific type of applications. However, middleware is intended to support a wide range of applications so developers must explore the trade-offs between the degree of application specificity and middleware generality \cite{middlewarechallenge}.

\emph{Security}: WSN middleware need to handle security issues in data processing and data communication. Since sensor networks are often deployed for sensitive applications like military surveillance, patient monitoring, forecasting systems, etc, data collected and distributed by these sensors will have to be genuine and authentic \cite{middlewaresurvey1}. However, due to limited resource availability, existing security algorithms may not be suitable for WSN so new security schemes need be developed to meet the security requirements of WSN.

\emph{QoS Support}: in WSN, we can view QoS from two perspectives, application and network. The former refers to QoS parameters specific to the application, such as sensor node measurement, deployment, coverage and number of active sensor nodes. The latter refers to how the supporting communication network can meet application needs while efficiently using network resources such as bandwidth and power consumption. Sometimes application-specific QoS requirements may conflict with network QoS requirements. For example, the application may always want to have more sensor nodes being active at the same time but the network, on the other hand, wants to let most of the sensors sleep. Therefore, it is up to middleware to balance the QoS requirements from both application and network perspective.

\begin{figure}
\centering
\figurecurrentwidth{wsn-middleware-category}
\caption{Category of existing WSN middleware}
\label{fig:wsn-middleware-category}
\end{figure}

We categorize the existing WSN middleware according to the programming abstraction provided. Programming abstraction is the most direct way for developers to interact with middleware. Figure \ref{fig:wsn-middleware-category} shows the category of existing middleware.

\subsection{Query-based Middleware}

\begin{figure}
\centering
\figurecurrentwidth{wsn-middleware-query}
\caption{Query-based middleware for WSN}
\label{fig:wsn-middleware-query}
\end{figure}

Query-based approach provides a SQL-like query language to higher level. As shown in Figure \ref{fig:wsn-middleware-query}, high level applications interact with the network using queries. To allow faster data delivery, the underlying network may group the data according to their types. The nodes may form a tree or clusters to further speed up the query processing.

The earliest work falling into this category is COUGAR \cite{cougar}. On the highest level, it uses SQL like query language. Sensors are modeled as abstract data types (ADT) in an object oriented fashion so the signal processing functions can be represented as a method of a type. An initial version of Cougar has been implemented on the actual sensor.

Some work such as TinyDB \cite{tinydb} uses a query-based approach with a couple of distinct language features such as event-based queries and aggregation. Internally, it defines some metadata for query optimization. A few power-based query optimization techniques were introduced such as power-based ordering and event query batching. For query dissemination, a semantic routing tree protocol was proposed. Dissemination of multiple queries with optimization is briefly discussed as the future work. TinyDB also discusses policies that have to be made when the data cannot be delivered due to time constraints and resource constraints.

In order to process the query more easily, the query-based middleware usually has certain network structures such as cluster or tree. For example, SINA is a query-based middleware for WSN. It assumes that the sensor nodes are formed into clusters and the underlying communication is attribute-based. On the highest level, it provides a SQLT for the users. SQLT is basically a SQL-like language and supports task scripting when the sensor meets the condition of the query. SINA is only evaluated in simulation and it doesn't seem to have any real implementation.

\subsection{Virtual Machine-based Middleware}

\begin{figure}
\centering
\figurecurrentwidth{wsn-middleware-vm}
\caption{Virtual machine-based middleware for WSN}
\label{fig:wsn-middleware-vm}
\end{figure}

Virtual machine-based middleware usually provides an instruction set for the applications. As illustrated in Figure \ref{fig:wsn-middleware-vm}, the instructions serve as the interface for the high level applications while the actual services are provided by the underlying modules. Depending on their complexity, some modules may have more than one instructions linked to them.

Some of the existing works use virtual machine models that have already been developed such as JVM. For example, MagnetOS \cite{magnetos} provides the image of JVM 1.3. Two algorithms have been proposed to dynamically place the application modules on sensor nodes in order to save energy. MagnetOS seems to have been implemented but not on Berkeley sensor motes.

However, virtual machines such as JVM may be too heavy weighted to be executed on sensor nodes. Therefore, some work chose to develop new VM models. For example, Mat\'{e} \cite{mate} is a VM based approach for WSN middleware. Three contexts are defined and they correspond to three events: clock timers, message reception and message send request. Each context has a stack structure to allow concise code size. Based on such kind of stack structure, coding in Mat\'{e} is also stack-based. Mat\'{e} has been implemented in TinyOS.

Other middleware may require supporting components. For example, Smart Messages (SM) \cite{smartmessage} mainly contains three components. A VM is used to provide hardware abstraction for SM execution. A tag space offers a name-based memory and consists of (name, data) pairs. A code cache is used to cache some of the codes for efficiency. With the help of these components, SM uses content-based routing and migration based on the tag spaces. Two routing algorithms have been implemented. One is based on Ad hoc On-Demand Distance Vector (AODV) \cite{aodv}, the other one is based on Greedy Perimeter Stateless Routing (GPSR) \cite{gpsr}. SM discusses security issues and provides the Admission Manager module to achieve the security goal. SM has been implemented on Pocket PC.

\subsection{Event-based Middleware}
Event-based middleware first allows the users to define events. Then the corresponding event handler will be specified and executed once certain type of event happens. Existing event-based middleware mostly deals with primitive events and many of them use SQL to define and subscribe to events. 

A good example for event-based middleware using SQL is DSWare \cite{dsware}. DSWare uses a SQL-like language to express describe events. The SQL commands 'insert' and 'delete' are used to register and cancel a specific event. However, with these simple commands, DSWare can only support primitive event detection. DSWare is implemented only in simulations.

In addition to events subscription and report, some other works make use of events to update codes. Impala \cite{impala} supports application module updates based on the reception of different kinds of events. In their paper, the authors focus on the architecture of the middleware Impala. No detail is provided about the high-level API provided by Impala. There are three main modules in the middleware: Application Adapter, Application Updater and Event Filter. Impala has been implemented on Pocket PC with Linux operating system. The work is compared to Mat\'{e} in terms of design and programming paradigm provided to the application layer. It didn't compare the actual performance.

\subsection{Agent-based Middleware}
An agent-based approach usually treats the codes running on individual sensor nodes as mobile agents. Codes can therefore, move between different sensor nodes. One of the motivations to use an agent-based approach is to allow multiple applications to be executed on the same network. One of such example is Agilla \cite{agilla}. Agilla is based on Mat\'{e} and uses stack architecture to reduce the length of the instructions. On each of the sensor node, a max number of 4 agents can be supported at the same time. Agents can be cloned or migrated depending on the application. Inter-agent coordination is achieved through a tuple space and an acquaintance provided by the Agilla middleware.

Different from previous middlewares, agent-based approaches usually do not have a de facto language or scripts and different work may adopt different approaches. For example, Agilla uses stack-based instructions. Another work SensorWare \cite{sensorware} uses a Tcl core as the scripting language provided to the upper layer. The program is basically composed of event handlers which perform tasks based on the events received. A mobile agent-based approach is used in the sense that the script can be replicated and migrated in several sensor nodes. SensorWare seems to have a module, namely Admission Control module, for security. SensorWare has been implemented on Pocket PC. Its performance is briefly compared with SQLT (used in SINA) in terms of code size.

\subsection{Middleware with Other Programming Abstractions}
The middleware listed before use popular and well-understood programming abstractions. There are, however, other works that use programming abstractions which are more specific to certain applications or are simply not as popular as the previous ones. For instance, tuple space is a popular approach in traditional distributed systems but may not be as well-known as queries. TinyLIME \cite{tinylime} is a middleware that is based on tuple space. TinyLIME is built on top of LIME which uses a tuple space approach. The authors assume a network model where sensor nodes are sparsely scattered in a certain region. They communicate with a base station within its one-hop communication region. Base station and clients are connected with each other using multihop communication. The sensory data of a sensor node is represented as a mobile agent on the base station. TinyLIME has been implemented on both Berkeley motes and notebook with Java.

Some works develop programing abstractions which are specific to certain applications. For example, EnviroTrack \cite{envirotrack} introduces a programming language designed specifically for object tracking in WSN. The EnviroTrack compiler will first compile the program into C programs. The language has hid out the network layer to the application programmer and it provides an object-based naming mechanism. EnviroTrack has been implemented in TinyOS on Mica motes.

Some works may not emphasizes on programming abstractions but they do address some issues listed in Section \ref{sec:middleware-issues}, for example, data fusion through clustering. Yu et al. \cite{clustermiddleware} specifically discuss the design issue of a cluster-based middleware. In this paper, the authors first discuss some general design principles for designing a WSN middleware. The discussed design principles include data-centric mechanisms, application knowledge, localized algorithms, lightweight and QoS. Based on these design principles, the authors argue that a cluster-based approach is more suitable to meet those design principles. The authors also briefly describe the architecture for such kind of middleware.

Apart from clustering, QoS is also an important topic in WSN. MiLAN \cite{milan} focuses on QoS and it introduces the concept of proactive network. In MiLAN, the authors argue that the previous works has focused on designing new network-level protocols without considering existing standards or how applications use the protocols. MiLAN extends the network stack and allows applications to specify the required variables and QoS requirements associated with them. A state-based graph is used to let the application describe variables. In the network layer, MiLAN uses a service discovery protocol. The implementation details haven't been discussed in the paper.

Cross-layer is also addressed by some middleware design. TinyCubus \cite{tinycubus} features a cross-layer design. There are mainly three modules in TinyCubus. The first component, data management frameworks provides a set of standard data management and system components. The components are selected based on current system parameters, application parameters and optimization parameters. The second component, cross-layer framework, provides a generic interface to support parameterization of components using cross-layer interactions. It uses a specification language that allows for the description of the data types and information required and provided by each component. The third component, tiny configuration engine, is used to control the topology and the role of each sensor. Code distribution can use such kind of configuration information to distribute the code more effectively.

\subsection{Summary of Existing WSN Middleware}
Most of the existing works describe their abstractions in details. Existing approaches include query-based approaches \cite{cougar, sina, tinydb}, VM-based approaches \cite{magnetos, mate, smartmessage}, tuple space-base approaches \cite{tinylime} and mobile agent-based approaches \cite{agilla, sensorware}. In addition to these well-known programming paradigms, some works provide some application-specific abstractions. For example, Enviro Track \cite{envirotrack} provide a programming model which is suitable for object tracking applications.

In terms of network issues such as routing and data fusion, some of the works have briefly described the related issues. For example, SINA \cite{sina} uses a cluster-based approach to perform data aggregation and discuss the routing issues about how to deliver the data to a mobile subscriber. SM \cite{smartmessage} uses content-based routing and migration based on the tag spaces. Two routing algorithms have been implemented. One is based on AODV and the other is based on GPSR. Yu et al. \cite{clustermiddleware} further argue that a cluster-based approach is more suitable. TinyLIME \cite{tinylime} briefly describe the communication scheduling issues for WSN where most of the sensors sleep during the most of the time. TinyDB \cite{tinydb} seems to have a most comprehensive discussion of the related network issues such as the construction and maintenance of semantic routing trees. The authors also discuss various kinds of policies for delivering the data.

In terms of implementation, some works \cite{sina, dsware}, seem to have been implemented only in simulation. For real world implementation, certain earlier works \cite{impala, sensorware, smartmessage} make use of platforms such as pocket PC which are more powerful and expensive than those sensor nodes for large-scale deployment. With the increasing popularity for the Berkeley sensor motes \cite{crossbow} among academia, recent works \cite{mate, tinylime, tinydb, envirotrack, agilla} has been implemented on those less powerful sensor nodes. TinyCubus \cite{tinycubus} has been implemented in TOSSIM \cite{tossim} which is a simulator provided by TinyOS \cite{nesc}. Codes created for TOSSIM can usually be deployed in real Berkeley sensor motes easily. Other works don't seem to describe the implementation details.

In terms of evaluation, most of the existing works don't have much formal mathematical models for analysis. Since middleware is usually targeted to a specific area of applications, it is also difficult to fairly compare the performance between middleware with completely different designs. As a result, most of the works don't compare with existing works. Instead, some works \cite{sina, mate, sensorware, smartmessage, agilla} evaluate the work by creating applications based on the middleware. Some works \cite{impala, dsware, clustermiddleware, tinycubus, tinylime}  evaluate the work by setting up a testbed either in real world or in simulation and performing some experiments based on the predefined metrics. Other works \cite{envirotrack, tinydb} are already very application-specific and simulations/experiments according to the predefined metrics can also be regarded as application simulation/experiments.

Recently, the security and QoS issues in WSN middleware have also attracted increasing attentions \cite{milan}.