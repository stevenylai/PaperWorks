\section{Introduction}
\label{sec:introduction}

\begin{figure}
\centering
\subfloat[Centralized]{\label{fig:room-a}\figurehalfwidth{room-a}}
\subfloat[Distributed]{\label{fig:room-b}\figurehalfwidth{room-b}}
\caption{Motivating application for indoor monitoring}
\label{fig:rooms}
\end{figure}

Event processing is important for many Wireless Sensor Network (WSN) applications such as intelligent transportation systems \cite{klein:its}, smart buildings \cite{lynch:shm} and healthcare \cite{lo:ban}. In these applications, the events sensor nodes detect events which reflect the environmental changes and the systems respond to these events accordingly. Events may be primitive or composite. Primitive events (e.g. when the temperature exceeds certain threshold) can be detected by a single sensor node without having to cooperate with others. On the other hand, \emph{composite events} consist of multiple primitive events. They reflect a serial of environmental changes with spatial and temporal relations among them and must be detected collaboratively by different sensor nodes.

Composite event processing is much more challenging than primitive event processing. Some composite events may consist of sub-events which are also composite events on their own. For instance, in an intelligent transportation system, the traffic jam event may be defined as too many cars waiting on a road. This event, however, may not be directly detected by a single sensor node. Instead, it may come from many sub-events such as the number of the vehicles on a road and the speed of the vehicles. The speed of the vehicles may, in turn, be collaboratively measured by different sensor nodes on a same road. Once a traffic jam event has been detected, we may need to inform other vehicles or the traffic light controller so that the corresponding adjustment may be made to improve the efficiency of the transportation system. All the processing need to be done in a resource constrained environment with unreliable wireless communication.

Because of the complexity in composite event processing in WSN applications, a middleware is desirable to hide the details. It should achieve the following design goals:
\begin{enumerate}
\item \emph{Event abstraction}: since composite events are collaboratively processed by different sensor nodes in the network, they introduce extra complexity because of the resource constraints and unreliable communication. A middleware framework providing high level event abstraction is needed to ease the application development.
\item \emph{Re-usability and flexibility}: different applications may share certain common modules during event processing. They may also have other different modules. A middleware framework can help so that common modules may be used and different modules may be replaced without affecting others.
\end{enumerate}

To achieve the first goal, we need to provide a common event-based programming model for different applications. The event model should have high-level operators or functions and allow the users to specify events in a declarative way. We show how this can be achieved through several examples. First, consider a monitoring application shown in Figure \ref{fig:rooms}. The composite event consists of two sub-events to be detected in two different rooms, Room A and Room B. It occurs when the temperature in room A rises to a certain threshold and after 5 minutes, the temperature in room B also reaches that threshold. To define such a scenario, the user will probably set up some composites events through some logical operators such as: \(roomA.temp \geq 30, roomB.temp \geq 30, timeB - timeA \geq 5\) Second, we consider an ITS application scenario. In such an application, as shown in Figure \ref{fig:its}, the sensor nodes are placed along the road to detect the presence of the vehicles. These events are gathered for various purposes such as collision avoidance, traffic light control and over-speed detection. Similarly, those scenarios may be defined through some operators. For instance, if we divide the distance by time, then we can obtain the speed of a car. If the speed is greater than a threshold, then it is considered as over-speeding. These example shows that while the underlying event processing mechanisms may be complicated, it is possible to provide a high level declarative event definition language to let the users only focus on defining the relations among events.

\begin{figure}
\centering
\subfloat[Centralized]{\label{fig:its-centralized}\figurehalfwidth{its-centralized}}
\subfloat[Distributed]{\label{fig:its-distributed}\figurehalfwidth{its-distributed}}
\caption{Motivating application for ITS}
\label{fig:its}
\end{figure}

To achieve the second goal, we need to have a modulized and layered middleware design so that it is easy to replace individual modules or layers without affecting the rest of the system. Such architecture is important because different WSN applications may have very different underlying mechanisms for processing composite events. Unlike traditional centralized event systems, where all the data can be gathered for processing the events, in WSN, sensor nodes usually do not have the global knowledge of all the events in the network. Instead, many events are detected locally to save communication costs. Moreover, different applications may have different requirements for event processing. Some applications may want energy saving while others may want higher reliability. For example, an indoor temperature monitoring application with only a few sensors may gather the data in a centralized fashion as shown in Figure \ref{fig:room-a}. However, if more sensors are to be deployed in the room, a distributed approach may be more desirable. As shown in Figure \ref{fig:room-b}, instead of sending the data to the sink, the senor nodes may choose to send data to a nearby senor nodes which act as the event detector for some sub-events. The detectors will try to detect the sub-event first. Then, only after the sub-event has been detected, the data will be transmitted to the sink node. By doing so, we effectively avoid transmitting all the raw data to the sink. Similarly, detection of these events can be centralized or distributed as shown in Figure \ref{fig:its-centralized} and \ref{fig:its-distributed}. However, different from the indoor monitoring application, in ITS, it might be better if the sensor nodes transmit the events of the vehicles along the road instead of forwarding the data to the geographical center of the road. 

In light of the above examples, the middleware should hide the underlying event processing details from the application developers. Modifications in the event processing mechanisms will not affect the high level applications. In summary, the middleware should have the following features:
\begin{itemize}
\item \emph{High level abstraction for composite events}: application users may interact with the underlying event services through the high level abstraction without having to worry about the underlying event processing mechanisms.
\item \emph{Flexible architecture for event processing}: it is possible to implement customized event processing mechanisms without affecting the operations of high level users
\end{itemize}

In this paper, we propose a middleware framework called PSWare. PSWare uses a flexible architecture where different event processing algorithms can be easily integrated. The contribution of the paper can be summarized as follows:
\begin{itemize}
\item We described the design of PSWare. PSWare features a flexible architecture. Different application domains can easily implement event processing mechanisms on top of PSWare.
\item We developed several real WSN applications on top of PSWare. The applications are from different domains such as indoor temperature monitoring, intelligent transportation system and structural health monitoring.
\item We performed experiments on PSWare to demonstrate its effectiveness in helping developing event-based applications in WSN.
\end{itemize}

A lot of middleware work for WSN has been proposed. Existing approaches event-based middleware for WSN mostly include query-based approach \cite{tinydb} and publish/subscribe approach \cite{complexevent}. However, these works either cannot work well for composite event-based systems or are not flexible enough to allow implementation of customized event processing algorithms. 

%In comparison with that in distributed systems, detecting composite events in WSN poses more challenges because of the high network dynamics and resource constraints. First, event relations may need to be taken into consideration when detecting. For example, 

%There are already some works that have proposed event detection algorithms \cite{lai:ted} for WSN. However, in order to make these algorithms work for real world WSN applications, more work needs to be done. One approach is to implement application-specific algorithms. In this approach, it is easier to improve the event detection efficiency by taking advantage of application-specific information. However, we may have to re-invent the wheel if similar algorithms are implemented in different applications. A better approach is to have a generic software layer for event detection and applications will be built on top of this. This can effectively avoid re-inventing the wheel but the software must be flexible enough so that it is capable of supporting a wide range of applications.

The rest of the paper is organized as follows: Section \ref{sec:background} introduces the background and related works for PSWare. In Section \ref{sec:model}, we describe the event-based programming model supported by PSWare. Section \ref{sec:design} describes how PSWare is designed for composite event processing - one of the most important features in PSWare. In Section \ref{sec:flexibility}, we describe another important feature in PSWare - the support for flexibility. Section \ref{sec:pswareImpl} shows how to use PSware to implement applications such as indoor monitoring, intelligent transportation systems and smart car park system. Then based on these applications, we evaluate PSWare for its effectiveness in helping developing event-based applications. Section \ref{sec:conclusion} concludes the paper.